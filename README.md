#### DDDはドメインの知識に焦点を当てた設計手法

##### DDDの用語は大別すると２種類
- モデリング
  - ソフトウェアにとって重要な概念を抽出。事象・概念を抽象化する作業。
- パターン
  - 概念を実装に落とし込む

##### 用語
- モデル
  - 現実の事象あるいは概念を抽象化した概念
- ドメインモデル
  - ドメインの概念をモデリングして得られたモデル
- ドメインオブジェクト
  - ドメインモデルをソフトウェアで動作するモジュールとして表現したもの

##### パターン

アプリケーションを表現するパターンのものが知識を表現するパターンのものを利用する関係性がある。

- 知識を表現（ドメインオブジェクト）
  - 値オブジェクト
    - ドメイン・システム固有の概念を値として表現
    - 特徴
      - 不変である
      - 交換が可能
      - 等価性によって比較される
    - いつ使うかのモチベーション
      - 表現力を増す
      - 不正な値を存在させない
      - 誤った代入を防ぐ
      - ロジックの散在を防ぐ
        - 理想は1つのルールの変更に対してコードの変更箇所が1箇所
  - エンティティ
    - 可変である
    - 同じ属性であっても区別される
    - 同一性により区別される
      - 値オブジェクトは全ての属性が比較対象だが、エンティティは同一性を表す識別子（ID）だけが比較対象になる
    - エンティティか値オブジェクトかの判断基準
      - ライフサイクルをもち連続性のある概念はエンティティ
  - ドメインサービス
    - 値オブジェクト・エンティティでうまく表現できない知識を取り扱う。
    - ドメインの活動など
    - エンティティや値オブジェクトに記述すると不自然なふるまいのみに限定すること
      - ドメインモデル貧血症に繋がる
    - そのオブジェクトの定義に納まらない操作を無理やり押し込むことになりそうな時はサービスに切り出す
    - サービスとは、クライアントのために何かを行うもの。物事ではなく、活動や行動であることが多い。
      - サービスは状態を持たない。
- アプリケーションを実現
  - リポジトリ
    - ドメインオブジェクトの永続化(save,store)や再構築(find)の処理を抽象的に扱うオブジェクト。
      - 永続化...インスタンスを保存し、復元できるようにする。
    - ドメインオブジェクト⇄レポジトリ⇄データストア
  - アプリケーションサービス
    - ドメインオブジェクトを協調させユースケースを実現する。
    - ドメインオブジェクトのふるまいを呼び出す役目！！
      - ドメインオブジェクトを直接公開せず、クライアントにはDTOにデータを差し替えて返却する！
        - ドメインのメソッドを呼び出すことを防ぐ！
    - あくまでドメインオブジェクトのタスク調整に徹するべき
      - Ex.ユーザーの重複を許さない。のようなロジックはドメインルールである。これをアプリケーションサービスに書いた場合、重複確認ロジックが変更した場合（ユーザ名→メアド）アプリケーションサービスの登録・更新処理などでは同じロジックの重複があるため多くの修正が発生する。
      - こうすることでアプリケーションはドメインロジック/サービスを呼び出すだけでよく重複確認ロジックは隠蔽される。
    -  Commandオブジェクト...間接的にアプリケーションサービスの処理を制御することと同義。処理のファサード（複雑な処理を単純な操作にまとめること）
  - ファクトリ
    - オブジェクトを作る知識に特化したオブジェクト。生成に関する知識を一箇所にまとめる。
- 知識を表現、より発展的
  - 集約
    - 整合性を保つ境界。値オブジェクトやエンティティを束ねて複雑なドメインの概念を表現。
  - 仕様
    - オブジェクトの評価を行う。ある特定の条件下にあるかを判定する評価の振る舞いをモジュールとしてうまく表現する。

- ドメインオブジェクトを定義するメリット
  - コードのドキュメント性が高まる
    - ドメインオブジェクトを見ればドメインモデルがわかる？（ユーザー名は3文字以上など）
  - ドメインにおける変更をコードに伝えやすくする
    - ドメインオブジェクトにふるまいやルールを記述することは、ドメインからドメインモデルへ伝播した変化をドメインオブジェクトまで到達させるために必要なこと。
    
- 依存関係
  - Service Locatorバターン
    - ServiceLocatorオブジェクトに依存解決先のオブジェクトを登録し、呼び出し先はserviceLocator.register(),resolve()で呼び出すだけでよくなる。
    - アンチパターンであるとも言われている
      - 依存関係が外部から見えずらい
      - テストの維持が難しくなる
    - DIパターン
      - 依存関係の変更に強制力を持たせることができる
        - コンストラクタに定義しているのでコンパイルエラーで気づける
    - Ioc Containerパターン
      - DIでは毎回依存するオブジェクトのインスタンス化が必要となった。この問題を解決するもの。
      - 設定にしたがって依存関係を解決し、インスタンスを生成する。
- ファクトリ
  - 複雑なオブジェクトの生成処理をオブジェクトとして定義する
    - 複雑なオブジェクトの生成過程はある種の知識である。
    - 生成処理自体はドメインを表現する層の責務であることには変わらない。
  - 単純なクラス（User）をインスタンス化したい時に、DB接続・ID採番処理が必要な時などに、IUserFactory.create()というインターフェースを作成し、Userの生成処理はクラス内で実装しておく。